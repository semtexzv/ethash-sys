#![allow(non_camel_case_types,non_snake_case,non_upper_case_globals)]
// Original source code retrieved from: https://github.com/ethereum-mining/ethminer


/* automatically generated by rust-bindgen */


#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const ETHASH_REVISION: ::std::os::raw::c_uint = 23;
pub const ETHASH_DATASET_BYTES_INIT: ::std::os::raw::c_uint = 1073741824;
pub const ETHASH_DATASET_BYTES_GROWTH: ::std::os::raw::c_uint = 8388608;
pub const ETHASH_CACHE_BYTES_INIT: ::std::os::raw::c_uint = 1073741824;
pub const ETHASH_CACHE_BYTES_GROWTH: ::std::os::raw::c_uint = 131072;
pub const ETHASH_EPOCH_LENGTH: ::std::os::raw::c_uint = 30000;
pub const ETHASH_MIX_BYTES: ::std::os::raw::c_uint = 128;
pub const ETHASH_HASH_BYTES: ::std::os::raw::c_uint = 64;
pub const ETHASH_DATASET_PARENTS: ::std::os::raw::c_uint = 256;
pub const ETHASH_CACHE_ROUNDS: ::std::os::raw::c_uint = 3;
pub const ETHASH_ACCESSES: ::std::os::raw::c_uint = 64;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::std::os::raw::c_uint = 1;
pub const _BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const ENABLE_SSE: ::std::os::raw::c_uint = 0;
pub const NODE_WORDS: ::std::os::raw::c_uint = 16;
pub const MIX_WORDS: ::std::os::raw::c_uint = 32;
pub const MIX_NODES: ::std::os::raw::c_uint = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
                  -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
                   -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
                   -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
                  -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
                  -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
                   -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
    ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
    ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __locales as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
        const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
            * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
            * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __locale_struct ) ) . __names as * const
        _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
                     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
                   -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
                  -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
                      -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
                    -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
                  -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
                   -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
                    -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
                      -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
                     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
                    -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
                     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
                   -> *mut ::std::os::raw::c_char;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const max_align_t ) ) .
            __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
    concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const max_align_t ) ) .
            __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
    concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
/// Type of a seedhash/blockhash e.t.c.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ethash_h256 {
    pub b: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_ethash_h256() {
    assert_eq!(::std::mem::size_of::<ethash_h256>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ethash_h256 ) ));
    assert_eq! (::std::mem::align_of::<ethash_h256>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ethash_h256 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_h256 ) ) . b as * const _ as usize
    } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_h256 ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for ethash_h256 {
    fn clone(&self) -> Self { *self }
}
pub type ethash_h256_t = ethash_h256;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ethash_light {
    pub cache: *mut ::std::os::raw::c_void,
    pub cache_size: u64,
    pub block_number: u64,
}
#[test]
fn bindgen_test_layout_ethash_light() {
    assert_eq!(::std::mem::size_of::<ethash_light>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ethash_light ) ));
    assert_eq! (::std::mem::align_of::<ethash_light>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ethash_light ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_light ) ) . cache as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_light ) , "::" ,
                stringify ! ( cache ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_light ) ) . cache_size as * const
        _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_light ) , "::" ,
                stringify ! ( cache_size ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_light ) ) . block_number as *
        const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_light ) , "::" ,
                stringify ! ( block_number ) ));
}
impl Clone for ethash_light {
    fn clone(&self) -> Self { *self }
}
pub type ethash_light_t = *mut ethash_light;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ethash_return_value {
    pub result: ethash_h256_t,
    pub mix_hash: ethash_h256_t,
    pub success: bool,
}
#[test]
fn bindgen_test_layout_ethash_return_value() {
    assert_eq!(::std::mem::size_of::<ethash_return_value>() , 65usize , concat
    ! ( "Size of: " , stringify ! ( ethash_return_value ) ));
    assert_eq! (::std::mem::align_of::<ethash_return_value>() , 1usize ,
    concat ! (
                "Alignment of " , stringify ! ( ethash_return_value ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_return_value ) ) . result as *
        const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_return_value ) ,
                "::" , stringify ! ( result ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_return_value ) ) . mix_hash as *
        const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_return_value ) ,
                "::" , stringify ! ( mix_hash ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const ethash_return_value ) ) . success as *
        const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ethash_return_value ) ,
                "::" , stringify ! ( success ) ));
}
impl Clone for ethash_return_value {
    fn clone(&self) -> Self { *self }
}
pub type ethash_return_value_t = ethash_return_value;
extern "C" {
    /**
 * Allocate and initialize a new ethash_light handler
 *
 * @param block_number   The block number for which to create the handler
 * @return               Newly allocated ethash_light handler or NULL in case of
 *                       ERRNOMEM or invalid parameters used for @ref ethash_compute_cache_nodes()
 */
    pub fn ethash_light_new(block_number: u64) -> ethash_light_t;
}
extern "C" {
    /**
 * Frees a previously allocated ethash_light handler
 * @param light        The light handler to free
 */
    pub fn ethash_light_delete(light: ethash_light_t);
}
extern "C" {
    /**
 * Calculate the light client data
 *
 * @param light          The light client handler
 * @param header_hash    The header hash to pack into the mix
 * @param nonce          The nonce to pack into the mix
 * @return               an object of ethash_return_value_t holding the return values
 */
    pub fn ethash_light_compute(light: ethash_light_t,
                                header_hash: ethash_h256_t, nonce: u64)
                                -> ethash_return_value_t;
}
extern "C" {
    /**
 * Calculate the seedhash for a given block number
 */
    pub fn ethash_get_seedhash(block_number: u64) -> ethash_h256_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
            as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
            as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
            as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
        _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
            as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
            as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
            as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
            as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
            as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
        _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
            as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
            usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
            usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
            usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
            usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
            as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
            as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
        _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
            usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
            usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
            usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
            usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
            usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
            usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
            usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
            usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
            usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
            usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
    concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
    concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
            * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
            usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
            usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
            usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
            usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
            usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
::std::option::Option<unsafe extern "C" fn(__cookie:
                                           *mut ::std::os::raw::c_void,
                                           __buf:
                                           *mut ::std::os::raw::c_char,
                                           __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
::std::option::Option<unsafe extern "C" fn(__cookie:
                                           *mut ::std::os::raw::c_void,
                                           __buf:
                                           *const ::std::os::raw::c_char,
                                           __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
::std::option::Option<unsafe extern "C" fn(__cookie:
                                           *mut ::std::os::raw::c_void,
                                           __pos: *mut __off64_t,
                                           __w: ::std::os::raw::c_int)
                                           -> ::std::os::raw::c_int>;
pub type __io_close_fn =
::std::option::Option<unsafe extern "C" fn(__cookie:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
                      -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
                       -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
                  -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
                    -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
                    -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
                          -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
                         -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
                            -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
                -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
                 -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
                  -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
                           -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
                   -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
                   -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct node {
    pub bytes: __BindgenUnionField<[u8; 64usize]>,
    pub words: __BindgenUnionField<[u32; 16usize]>,
    pub double_words: __BindgenUnionField<[u64; 8usize]>,
    pub bindgen_union_field: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_node() {
    assert_eq!(::std::mem::size_of::<node>() , 64usize , concat ! (
               "Size of: " , stringify ! ( node ) ));
    assert_eq! (::std::mem::align_of::<node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( node ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const node ) ) . bytes as * const _ as usize }
    , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( node ) , "::" ,
                stringify ! ( bytes ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const node ) ) . words as * const _ as usize }
    , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( node ) , "::" ,
                stringify ! ( words ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const node ) ) . double_words as * const _ as
            usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( node ) , "::" ,
                stringify ! ( double_words ) ));
}
impl Clone for node {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Allocate and initialize a new ethash_light handler. Internal version
 *
 * @param cache_size    The size of the cache in bytes
 * @param seed          Block seedhash to be used during the computation of the
 *                      cache nodes
 * @return              Newly allocated ethash_light handler or NULL in case of
 *                      ERRNOMEM or invalid parameters used for @ref ethash_compute_cache_nodes()
 */
    pub fn ethash_light_new_internal(cache_size: u64,
                                     seed: *const ethash_h256_t)
                                     -> ethash_light_t;
}
extern "C" {
    /**
 * Calculate the light client data. Internal version.
 *
 * @param light          The light client handler
 * @param full_size      The size of the full data in bytes.
 * @param header_hash    The header hash to pack into the mix
 * @param nonce          The nonce to pack into the mix
 * @return               The resulting hash.
 */
    pub fn ethash_light_compute_internal(light: ethash_light_t,
                                         full_size: u64,
                                         header_hash: ethash_h256_t,
                                         nonce: u64) -> ethash_return_value_t;
}
extern "C" {
    pub fn ethash_calculate_dag_item(ret: *const node, node_index: u32,
                                     cache: ethash_light_t);
}
extern "C" {
    pub fn ethash_get_datasize(block_number: u64) -> u64;
}
extern "C" {
    pub fn ethash_get_cachesize(block_number: u64) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
        _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
        _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
            * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
        & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
        const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
